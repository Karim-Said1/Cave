import LogEvent, { SecondaryExposure } from './LogEvent';
import ConfigEvaluation from './ConfigEvaluation';
import { ExplicitStatsigOptions } from './StatsigOptions';
import { Marker } from './Diagnostics';
import StatsigFetcher from './utils/StatsigFetcher';
import { StatsigUser } from './StatsigUser';
export default class LogEventProcessor {
    private options;
    private fetcher;
    private queue;
    private flushTimer;
    private loggedErrors;
    private deduper;
    private deduperTimer;
    private _nonExposedChecks;
    constructor(fetcher: StatsigFetcher, options: ExplicitStatsigOptions);
    log(event: LogEvent, errorKey?: string | null): void;
    flush(fireAndForget?: boolean): Promise<void>;
    shutdown(): Promise<void>;
    logStatsigInternal(user: StatsigUser | null, eventName: string, metadata: Record<string, unknown> | null, secondaryExposures?: SecondaryExposure[] | null, value?: string | number | null): void;
    incrementNonExposedChecks(name: string): void;
    private _appendAndResetNonExposedChecks;
    logGateExposure(user: StatsigUser, gateName: string, evaluation: ConfigEvaluation, isManualExposure: boolean): void;
    logConfigExposure(user: StatsigUser, configName: string, evaluation: ConfigEvaluation, isManualExposure: boolean): void;
    logLayerExposure(user: StatsigUser, layerName: string, parameterName: string, evaluation: ConfigEvaluation, isManualExposure: boolean): void;
    logConfigDefaultValueFallback(user: StatsigUser, message: string, metadata: Record<string, unknown>): void;
    private maybeAddManualExposureFlagToMetadata;
    private safeAddEvaulationDetailsToEvent;
    private isUniqueExposure;
    logDiagnosticsEvent(diagnostics: {
        context: string;
        markers: Marker[];
        initTimeoutMs?: number;
    }, user?: StatsigUser | null): void;
}
