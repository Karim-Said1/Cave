"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.Statsig = exports.StatsigServer = exports.Layer = exports.DynamicConfig = void 0;
var DynamicConfig_1 = __importDefault(require("./DynamicConfig"));
exports.DynamicConfig = DynamicConfig_1["default"];
var Errors_1 = require("./Errors");
var Layer_1 = __importDefault(require("./Layer"));
exports.Layer = Layer_1["default"];
var OutputLogger_1 = __importDefault(require("./OutputLogger"));
var StatsigInstanceUtils_1 = __importDefault(require("./StatsigInstanceUtils"));
var StatsigServer_1 = __importDefault(require("./StatsigServer"));
exports.StatsigServer = StatsigServer_1["default"];
exports.Statsig = {
    // These need to be exported, and we currently export a top level Statsig object
    // So in order to not make a breaking change, they must be exported as members of
    // that top level object
    DynamicConfig: DynamicConfig_1["default"],
    Layer: Layer_1["default"],
    StatsigServer: StatsigServer_1["default"],
    /**
     * Initializes the statsig server SDK.
     * This must be called before checking gates/configs or logging events.
     *
     * @param {string} secretKey - The secret key for this project from the statsig console. Secret keys should be kept secure on the server side, and not used for client-side integrations
     * @param {?StatsigOptions} [options={}] - manual sdk configuration for advanced setup
     * @returns {Promise<void>} - a promise which rejects only if you fail to provide a proper SDK Key
     * @throws Error if a Server Secret Key is not provided
     */
    initialize: function (secretKey, options) {
        var _a;
        if (options === void 0) { options = {}; }
        if (options.logger) {
            OutputLogger_1["default"].setLogger(options.logger);
        }
        var inst = (_a = StatsigInstanceUtils_1["default"].getInstance()) !== null && _a !== void 0 ? _a : new StatsigServer_1["default"](secretKey, options);
        if (StatsigInstanceUtils_1["default"].getInstance() == null) {
            StatsigInstanceUtils_1["default"].setInstance(inst);
        }
        return inst.initializeAsync(options);
    },
    /**
     * Gets the boolean result of a gate, evaluated against the given user.
     * An exposure event will automatically be logged for the gate.
     *
     * @param {StatsigUser} user - the user to check this gate value for
     * @param {string} gateName - the name of the gate to check
     * @returns {boolean} - The value of the gate for the user.  Gates are off (return false) by default
     * @throws Error if initialize() was not called first
     * @throws Error if the gateName is not provided or not a non-empty string
     */
    checkGateSync: function (user, gateName) {
        return this._enforceServer().checkGateSync(user, gateName);
    },
    getFeatureGateSync: function (user, gateName) {
        return this._enforceServer().getFeatureGateSync(user, gateName);
    },
    /**
     * Gets the boolean result of a gate, evaluated against the given user.
     * No exposure event will be logged.
     *
     * @param {StatsigUser} user - the user to check this gate value for
     * @param {string} gateName - the name of the gate to check
     * @returns {boolean} - The value of the gate for the user.  Gates are off (return false) by default
     * @throws Error if initialize() was not called first
     * @throws Error if the gateName is not provided or not a non-empty string
     */
    checkGateWithExposureLoggingDisabledSync: function (user, gateName) {
        return this._enforceServer().checkGateWithExposureLoggingDisabledSync(user, gateName);
    },
    getFeatureGateWithExposureLoggingDisabledSync: function (user, gateName) {
        return this._enforceServer().getFeatureGateWithExposureLoggingDisabledSync(user, gateName);
    },
    /**
     * Logs an exposure event for the gate
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} gateName - the name of the gate to expose
     */
    manuallyLogGateExposure: function (user, gateName) {
        return this._enforceServer().logGateExposure(user, gateName);
    },
    /**
     * Get the values of a dynamic config, evaluated against the given user.
     * An exposure event will automatically be logged for the dynamic config.
     *
     * @param {StatsigUser} user - the user to evaluate for the dyamic config
     * @param {string} configName - the name of the dynamic config to get
     * @returns {DynamicConfig} - the config for the user
     * @throws Error if initialize() was not called first
     * @throws Error if the configName is not provided or not a non-empty string
     */
    getConfigSync: function (user, configName) {
        return this._enforceServer().getConfigSync(user, configName);
    },
    /**
     * Get the values of a dynamic config, evaluated against the given user.
     * No exposure event will be logged.
     *
     * @param {StatsigUser} user - the user to evaluate for the dyamic config
     * @param {string} configName - the name of the dynamic config to get
     * @returns {DynamicConfig} - the config for the user
     * @throws Error if initialize() was not called first
     */
    getConfigWithExposureLoggingDisabledSync: function (user, configName) {
        return this._enforceServer().getConfigWithExposureLoggingDisabledSync(user, configName);
    },
    /**
     * Logs an exposure event for the dynamic config
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} configName - the name of the dynamic config to expose
     */
    manuallyLogConfigExposure: function (user, configName) {
        return this._enforceServer().logConfigExposure(user, configName);
    },
    /**
     * Get the values of an experiment, evaluated against the given user.
     * An exposure event will automatically be logged for the experiment.
     *
     * @param {StatsigUser} user - the user to evaluate for the experiment
     * @param {string} experimentName - the name of the experiment to get
     * @returns {DynamicConfig} - the experiment for the user, represented by a Dynamic Config object
     * @throws Error if initialize() was not called first
     */
    getExperimentSync: function (user, experimentName) {
        return this._enforceServer().getExperimentSync(user, experimentName);
    },
    /**
     * Get the values of an experiment, evaluated against the given user.
     * No exposure event will be logged.
     *
     * @param {StatsigUser} user - the user to evaluate for the experiment
     * @param {string} experimentName - the name of the experiment to get
     * @returns {DynamicConfig} - the experiment for the user, represented by a Dynamic Config object
     * @throws Error if initialize() was not called first
     */
    getExperimentWithExposureLoggingDisabledSync: function (user, experimentName) {
        return this._enforceServer().getExperimentWithExposureLoggingDisabledSync(user, experimentName);
    },
    /**
     * Logs an exposure event for the experiment
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} experimentName - the name of the experiment to expose
     */
    manuallyLogExperimentExposure: function (user, experimentName) {
        return this._enforceServer().logExperimentExposure(user, experimentName);
    },
    /**
     * Get the values of a layer, evaluated against the given user.
     * Exposure events will be fired when get or getValue is called on the resulting Layer class.
     *
     * @param {StatsigUser} user - the user to evaluate for the layer
     * @param {string} layerName - the name of the layer to get
     * @returns {Layer} - the layer for the user, represented by a Layer
     * @throws Error if initialize() was not called first
     */
    getLayerSync: function (user, layerName) {
        return this._enforceServer().getLayerSync(user, layerName);
    },
    /**
     * Get the values of a layer, evaluated against the given user.
     * No exposure events will be logged from the resulting Layer class.
     *
     * @param {StatsigUser} user - the user to evaluate for the layer
     * @param {string} layerName - the name of the layer to get
     * @returns {Layer} - the layer for the user, represented by a Layer
     * @throws Error if initialize() was not called first
     * @throws Error if the layerName is not provided or not a non-empty string
     */
    getLayerWithExposureLoggingDisabledSync: function (user, layerName) {
        return this._enforceServer().getLayerWithExposureLoggingDisabledSync(user, layerName);
    },
    /**
     * Logs an exposure event for the parameter in the given layer
     *
     * @param {StatsigUser} user - the user to log the exposure against
     * @param {string} layerName - the name of the layer
     * @param {string} parameterName - the name of the parameter in the layer
     */
    manuallyLogLayerParameterExposure: function (user, layerName, parameterName) {
        this._enforceServer().logLayerParameterExposure(user, layerName, parameterName);
    },
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     *
     * @param {StatsigUser} user - the user associated with this event
     * @param {string} eventName - the name of the event (name = Purchase)
     * @param {string | number | null} value - the value associated with the event (value = 10)
     * @param {Record<string, string> | null} metadata - other attributes associated with this event (metadata = {item_name: 'banana', currency: 'USD'})
     * @throws Error if initialize() was not called first
     */
    logEvent: function (user, eventName, value, metadata) {
        if (value === void 0) { value = null; }
        if (metadata === void 0) { metadata = null; }
        this._enforceServer().logEvent(user, eventName, value, metadata);
    },
    /**
     * Log an event for data analysis and alerting or to measure the impact of an experiment
     *
     * @param {LogEventObject} eventObject - an object containing the event data
     */
    logEventObject: function (eventObject) {
        this._enforceServer().logEventObject(eventObject);
    },
    /**
     * Informs the statsig SDK that the client is closing or shutting down
     * so the SDK can clean up internal state
     */
    shutdown: function () {
        this._enforceServer().shutdown();
        OutputLogger_1["default"].resetLogger();
    },
    /**
     * Returns the initialize values for the given user
     * Can be used to bootstrap a client SDK with up to date values
     * @param user the user to evaluate configurations for
     */
    getClientInitializeResponse: function (user, options) {
        return this._enforceServer().getClientInitializeResponse(user, options);
    },
    /**
     * Overrides the given gate with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the gate with the given value for that user only
     */
    overrideGate: function (gateName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideGate(gateName, value, userID);
    },
    /**
     * Overrides the given config or experiment with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the config/experiment with the given value for that user only
     */
    overrideConfig: function (configName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideConfig(configName, value, userID);
    },
    /**
     * Overrides the given layer with the provided value
     * If no userID is provided, it will override for all users
     * If a userID is provided, it will override the layer with the given value for that user only
     */
    overrideLayer: function (layerName, value, userID) {
        if (userID === void 0) { userID = ''; }
        this._enforceServer().overrideLayer(layerName, value, userID);
    },
    /**
     * Flushes all the events that are currently in the queue to Statsig.
     */
    flush: function () {
        var inst = StatsigInstanceUtils_1["default"].getInstance();
        if (inst == null) {
            return Promise.resolve();
        }
        return inst.flush();
    },
    /**
    * Clears all gate overrides
    */
    clearAllGateOverrides: function () {
        this._enforceServer().clearAllGateOverrides();
    },
    /**
     * Clears all config overrides
     */
    clearAllConfigOverrides: function () {
        this._enforceServer().clearAllConfigOverrides();
    },
    /**
     * Clears all layer overrides
     */
    clearAllLayerOverrides: function () {
        this._enforceServer().clearAllLayerOverrides();
    },
    /**
     * Gets all Feature Gate names
     *
     * @returns {string[]}
     */
    getFeatureGateList: function () {
        return this._enforceServer().getFeatureGateList();
    },
    /**
     * Gets all Dynamic Config names
     *
     * @returns {string[]}
     */
    getDynamicConfigList: function () {
        return this._enforceServer().getDynamicConfigList();
    },
    /**
     * Gets all Experiment names
     *
     * @returns {string[]}
     */
    getExperimentList: function () {
        return this._enforceServer().getExperimentList();
    },
    /**
     * Gets all Autotune names
     *
     * @returns {string[]}
     */
    getAutotuneList: function () {
        return this._enforceServer().getAutotuneList();
    },
    /**
     * Gets all Layer names
     *
     * @returns {string[]}
     */
    getLayerList: function () {
        return this._enforceServer().getLayerList();
    },
    syncConfigSpecs: function () {
        return this._enforceServer().syncStoreSpecs();
    },
    syncIdLists: function () {
        return this._enforceServer().syncStoreIdLists();
    },
    //#region Deprecated Async Methods
    /**
     * @deprecated Please use checkGateSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    checkGate: function (user, gateName) {
        return this._enforceServer().checkGate(user, gateName);
    },
    /**
     * @deprecated Please use getFeatureGateSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getFeatureGate: function (user, gateName) {
        return this._enforceServer().getFeatureGate(user, gateName);
    },
    /**
     * @deprecated Please use checkGateWithExposureLoggingDisabledSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    checkGateWithExposureLoggingDisabled: function (user, gateName) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._enforceServer().checkGateWithExposureLoggingDisabled(user, gateName)];
            });
        });
    },
    /**
     * @deprecated Please use getFeatureGateWithExposureLoggingDisabledSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getFeatureGateWithExposureLoggingDisabled: function (user, gateName) {
        return this._enforceServer().getFeatureGateWithExposureLoggingDisabled(user, gateName);
    },
    /**
     * @deprecated Please use getConfigSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getConfig: function (user, configName) {
        return this._enforceServer().getConfig(user, configName);
    },
    /**
     * @deprecated Please use getConfigWithExposureLoggingDisabledSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getConfigWithExposureLoggingDisabled: function (user, configName) {
        return this._enforceServer().getConfigWithExposureLoggingDisabled(user, configName);
    },
    /**
     * @deprecated Please use getExperimentSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getExperiment: function (user, experimentName) {
        return this._enforceServer().getConfig(user, experimentName);
    },
    /**
     * @deprecated Please use getExperimentWithExposureLoggingDisabledSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getExperimentWithExposureLoggingDisabled: function (user, experimentName) {
        return this._enforceServer().getConfigWithExposureLoggingDisabled(user, experimentName);
    },
    /**
     * @deprecated Please use getLayerSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getLayer: function (user, layerName) {
        return this._enforceServer().getLayer(user, layerName);
    },
    /**
     * @deprecated Please use getLayerWithExposureLoggingDisabledSync instead.
     * @see https://docs.statsig.com/server/deprecation-notices
     */
    getLayerWithExposureLoggingDisabled: function (user, layerName) {
        return this._enforceServer().getLayerWithExposureLoggingDisabled(user, layerName);
    },
    //#endregion
    _enforceServer: function () {
        var instance = StatsigInstanceUtils_1["default"].getInstance();
        if (instance == null) {
            throw new Errors_1.StatsigUninitializedError();
        }
        return instance;
    }
};
exports["default"] = exports.Statsig;
module.exports = __assign({ "default": exports.Statsig }, exports.Statsig);
