import { Handle, RequestEvent, RequestHandler } from '@sveltejs/kit';
import { i as FlagOption, J as JsonValue, f as FlagDeclaration, c as ApiData, a as FlagValuesType, F as FlagOverridesType, b as FlagDefinitionsType } from './types-CisDd6Kq.cjs';
import 'http';
import '@edge-runtime/cookies';

type FlagsMeta<ReturnValue> = {
    key: string;
    description?: string;
    origin?: string | Record<string, unknown>;
    options?: FlagOption<ReturnValue>[];
};
type RegularFlag<ReturnValue> = {
    (): ReturnValue | Promise<ReturnValue>;
    (
    /** Only provide this if you're retrieving the flag value outside of the lifecycle of the `handle` hook, e.g. when calling it inside edge middleware. */
    request?: Request, secret?: string): ReturnValue | Promise<ReturnValue>;
} & FlagsMeta<ReturnValue>;
type PrecomputedFlag<ReturnValue> = {
    (): never;
    (
    /** The route parameter that contains the precomputed flag values */
    code: string, 
    /** The flags which were used to create the code (i.e. the same array you passed to `precompute(...)`) */
    flagsArray: FlagsArray): ReturnValue | Promise<ReturnValue>;
} & FlagsMeta<ReturnValue>;
type Flag<ReturnValue> = RegularFlag<ReturnValue> | PrecomputedFlag<ReturnValue>;
type FlagsArray = readonly Flag<any>[];

/**
 * Declares a feature flag
 */
declare function flag<ValueType extends JsonValue = boolean | string | number, EntitiesType = any>(definition: FlagDeclaration<ValueType, EntitiesType>): Flag<ValueType>;
declare function getProviderData(flags: Record<string, Flag<any>>): ApiData;
/**
 * Establishes context for flags, so they have access to the
 * request and cookie.
 *
 * Also registers evaluated flags, except for flags used only after `resolve` calls in other handlers.
 *
 * @example Usage example in src/hooks.server.ts
 *
 * ```ts
 * import { createHandle } from 'flags/sveltekit';
 * import * as flags from '$lib/flags';
 *
 * export const handle = createHandle({ flags });
 * ```
 *
 * @example Usage example in src/hooks.server.ts with other handlers
 *
 * Note that when composing `createHandle` with `sequence` then `createHandle` should come first. Only handlers after it will be able to access feature flags.
 */
declare function createHandle({ secret, flags, }: {
    secret?: string;
    flags?: Record<string, Flag<any>>;
}): Handle;
declare function encryptFlagValues(value: FlagValuesType, secret?: string): Promise<string>;
declare function decryptFlagValues(encryptedData: string, secret?: string): Promise<FlagValuesType | undefined>;
declare function encryptOverrides(overrides: FlagOverridesType, secret?: string): Promise<string>;
declare function decryptOverrides(encryptedData: string, secret?: string): Promise<FlagOverridesType | undefined>;
declare function encryptFlagDefinitions(value: FlagDefinitionsType, secret?: string): Promise<string>;
declare function decryptFlagDefinitions(encryptedData: string, secret?: string): Promise<FlagDefinitionsType | undefined>;
/**
 * Evaluate a list of feature flags and generate a signed string representing their values.
 *
 * This convenience function call combines `evaluate` and `serialize`.
 *
 * @param flags - list of flags
 * @returns - a string representing evaluated flags
 */
declare function precompute<T extends FlagsArray>(flags: T, request: Request, secret?: string): Promise<string>;
/**
 * Generates all permutations given a list of feature flags based on the options declared on each flag.
 * @param flags - The list of feature flags
 * @param filter - An optional filter function which gets called with each permutation.
 * @param secret - The secret sign the generated permutation with
 * @returns An array of strings representing each permutation
 */
declare function generatePermutations(flags: FlagsArray, filter?: ((permutation: Record<string, JsonValue>) => boolean) | null, secret?: string): Promise<string[]>;
/**
 * Creates a well-known flags endpoint for SvelteKit.
 * @param getApiData a function returning the API data
 * @param options accepts a secret
 * @returns a RequestHandler
 */
declare function createFlagsDiscoveryEndpoint(getApiData: (event: RequestEvent) => Promise<ApiData> | ApiData, options?: {
    secret?: string | undefined;
}): RequestHandler;

export { createFlagsDiscoveryEndpoint, createHandle, decryptFlagDefinitions, decryptFlagValues, decryptOverrides, encryptFlagDefinitions, encryptFlagValues, encryptOverrides, flag, generatePermutations, getProviderData, precompute };
