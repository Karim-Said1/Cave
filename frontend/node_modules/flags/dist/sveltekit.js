import {
  deserialize,
  normalizeOptions,
  serialize
} from "./chunk-O6VYPARG.js";
import {
  HeadersAdapter,
  RequestCookiesAdapter,
  decryptFlagDefinitions,
  decryptFlagValues,
  decryptOverrides,
  encryptFlagDefinitions,
  encryptFlagValues,
  encryptOverrides,
  reportValue,
  verifyAccess,
  version
} from "./chunk-4EH7RLTD.js";
import {
  safeJsonStringify
} from "./chunk-2UDLZC33.js";

// src/sveltekit/index.ts
import {
  error,
  json
} from "@sveltejs/kit";
import { AsyncLocalStorage } from "node:async_hooks";
import { RequestCookies } from "@edge-runtime/cookies";

// src/sveltekit/precompute.ts
async function evaluate(flags, request) {
  return Promise.all(flags.map((flag2) => flag2(request)));
}
async function precompute(flags, request, secret) {
  const values = await evaluate(flags, request);
  return serialize2(flags, values, secret);
}
function combine(flags, values) {
  return Object.fromEntries(flags.map((flag2, i) => [flag2.key, values[i]]));
}
async function serialize2(flags, values, secret) {
  return serialize(combine(flags, values), flags, secret);
}
async function deserialize2(flags, code, secret) {
  return deserialize(code, flags, secret);
}
async function getPrecomputed(flagKey, precomputeFlags, code, secret) {
  const flagSet = await deserialize2(precomputeFlags, code, secret);
  return flagSet[flagKey];
}
function* cartesianIterator(items) {
  const remainder = items.length > 1 ? cartesianIterator(items.slice(1)) : [[]];
  for (let r of remainder)
    for (let h of items.at(0))
      yield [h, ...r];
}
async function generatePermutations(flags, filter = null, secret) {
  const options = flags.map((flag2) => {
    if (!flag2.options)
      return [false, true];
    return flag2.options.map((option) => option.value);
  });
  const list = [];
  for (const permutation of cartesianIterator(options)) {
    const permObject = permutation.reduce(
      (acc, value, index) => {
        acc[flags[index].key] = value;
        return acc;
      },
      {}
    );
    if (!filter || filter(permObject))
      list.push(permObject);
  }
  return Promise.all(list.map((values) => serialize(values, flags, secret)));
}

// src/sveltekit/env.ts
var default_secret = process.env.FLAGS_SECRET;
async function tryGetSecret(secret) {
  if (!default_secret) {
    try {
      const env = await import("$env/static/private");
      default_secret = env.FLAGS_SECRET;
    } catch (e) {
    }
  }
  secret = secret || default_secret;
  if (!secret) {
    throw new Error(
      "flags: No secret provided. Set an environment variable FLAGS_SECRET or provide a secret to the function."
    );
  }
  return secret;
}

// src/sveltekit/index.ts
function hasOwnProperty(obj, prop) {
  return obj.hasOwnProperty(prop);
}
var headersMap = /* @__PURE__ */ new WeakMap();
var cookiesMap = /* @__PURE__ */ new WeakMap();
function sealHeaders(headers) {
  const cached = headersMap.get(headers);
  if (cached !== void 0)
    return cached;
  const sealed = HeadersAdapter.seal(headers);
  headersMap.set(headers, sealed);
  return sealed;
}
function sealCookies(headers) {
  const cached = cookiesMap.get(headers);
  if (cached !== void 0)
    return cached;
  const sealed = RequestCookiesAdapter.seal(new RequestCookies(headers));
  cookiesMap.set(headers, sealed);
  return sealed;
}
async function resolveObjectPromises(obj) {
  const entries = Object.entries(obj);
  const resolvedEntries = await Promise.all(
    entries.map(async ([key, promise]) => {
      const value = await promise;
      return [key, value];
    })
  );
  return Object.fromEntries(resolvedEntries);
}
function getDecide(definition) {
  return function decide(params) {
    if (typeof definition.decide === "function") {
      return definition.decide(params);
    }
    if (typeof definition.adapter?.decide === "function") {
      return definition.adapter.decide({ key: definition.key, ...params });
    }
    throw new Error(`flags: No decide function provided for ${definition.key}`);
  };
}
function getIdentify(definition) {
  if (typeof definition.identify === "function") {
    return definition.identify;
  }
  if (typeof definition.adapter?.identify === "function") {
    return definition.adapter.identify;
  }
}
var requestMap = /* @__PURE__ */ new WeakMap();
function flag(definition) {
  const decide = getDecide(definition);
  const identify = getIdentify(definition);
  const flagImpl = async function flagImpl2(requestOrCode, flagsArrayOrSecret) {
    let store = flagStorage.getStore();
    if (!store) {
      if (requestOrCode instanceof Request) {
        store = requestMap.get(requestOrCode);
        if (!store) {
          store = createContext(
            requestOrCode,
            flagsArrayOrSecret ?? await tryGetSecret()
          );
          requestMap.set(requestOrCode, store);
        }
      } else {
        throw new Error("flags: Neither context found nor Request provided");
      }
    }
    if (typeof requestOrCode === "string" && Array.isArray(flagsArrayOrSecret)) {
      return getPrecomputed(
        definition.key,
        flagsArrayOrSecret,
        requestOrCode,
        store.secret
      );
    }
    if (hasOwnProperty(store.usedFlags, definition.key)) {
      const valuePromise2 = store.usedFlags[definition.key];
      if (typeof valuePromise2 !== "undefined") {
        return valuePromise2;
      }
    }
    const headers = sealHeaders(store.request.headers);
    const cookies = sealCookies(store.request.headers);
    const overridesCookie = cookies.get("vercel-flag-overrides")?.value;
    const overrides = overridesCookie ? await decryptOverrides(overridesCookie, store.secret) : void 0;
    if (overrides && hasOwnProperty(overrides, definition.key)) {
      const value2 = overrides[definition.key];
      if (typeof value2 !== "undefined") {
        reportValue(definition.key, value2);
        store.usedFlags[definition.key] = Promise.resolve(value2);
        return value2;
      }
    }
    let entities;
    if (identify) {
      if (!store.identifiers.has(identify)) {
        const entities2 = identify({
          headers,
          cookies
        });
        store.identifiers.set(identify, entities2);
      }
      entities = await store.identifiers.get(identify);
    }
    const valuePromise = decide({
      headers,
      cookies,
      entities
    });
    store.usedFlags[definition.key] = valuePromise;
    const value = await valuePromise;
    reportValue(definition.key, value);
    return value;
  };
  flagImpl.key = definition.key;
  flagImpl.defaultValue = definition.defaultValue;
  flagImpl.origin = definition.origin;
  flagImpl.description = definition.description;
  flagImpl.options = normalizeOptions(definition.options);
  flagImpl.decide = decide;
  flagImpl.identify = identify;
  return flagImpl;
}
function getProviderData(flags) {
  const definitions = Object.values(flags).reduce(
    (acc, d) => {
      acc[d.key] = {
        options: normalizeOptions(d.options),
        origin: d.origin,
        description: d.description
      };
      return acc;
    },
    {}
  );
  return { definitions, hints: [] };
}
function createContext(request, secret, params) {
  return {
    request,
    secret,
    params: params ?? {},
    usedFlags: {},
    identifiers: /* @__PURE__ */ new Map()
  };
}
var flagStorage = new AsyncLocalStorage();
function createHandle({
  secret,
  flags
}) {
  return async function handle({ event, resolve }) {
    secret ?? (secret = await tryGetSecret(secret));
    if (flags && // avoid creating the URL object for every request by checking with includes() first
    event.request.url.includes("/.well-known/") && new URL(event.request.url).pathname === "/.well-known/vercel/flags") {
      return handleWellKnownFlagsRoute(event, secret, flags);
    }
    const flagContext = createContext(
      event.request,
      secret,
      event.params
    );
    return flagStorage.run(
      flagContext,
      () => resolve(event, {
        transformPageChunk: async ({ html }) => {
          const store = flagStorage.getStore();
          if (!store || Object.keys(store.usedFlags).length === 0)
            return html;
          const encryptedFlagValues = await encryptFlagValues(
            await resolveObjectPromises(store.usedFlags),
            secret
          );
          return html.replace(
            "</body>",
            `<script type="application/json" data-flag-values>${safeJsonStringify(encryptedFlagValues)}</script></body>`
          );
        }
      })
    );
  };
}
async function handleWellKnownFlagsRoute(event, secret, flags) {
  const access = await verifyAccess(
    event.request.headers.get("Authorization"),
    secret
  );
  if (!access)
    return new Response(null, { status: 401 });
  const providerData = getProviderData(flags);
  return Response.json(providerData, {
    headers: { "x-flags-sdk-version": version }
  });
}
async function encryptFlagValues2(value, secret) {
  return encryptFlagValues(value, await tryGetSecret(secret));
}
async function decryptFlagValues2(encryptedData, secret) {
  return decryptFlagValues(encryptedData, await tryGetSecret(secret));
}
async function encryptOverrides2(overrides, secret) {
  return encryptOverrides(overrides, await tryGetSecret(secret));
}
async function decryptOverrides2(encryptedData, secret) {
  return decryptOverrides(encryptedData, await tryGetSecret(secret));
}
async function encryptFlagDefinitions2(value, secret) {
  return encryptFlagDefinitions(value, await tryGetSecret(secret));
}
async function decryptFlagDefinitions2(encryptedData, secret) {
  return decryptFlagDefinitions(encryptedData, await tryGetSecret(secret));
}
async function precompute2(flags, request, secret) {
  return precompute(flags, request, await tryGetSecret(secret));
}
async function generatePermutations2(flags, filter = null, secret) {
  return generatePermutations(flags, filter, await tryGetSecret(secret));
}
function createFlagsDiscoveryEndpoint(getApiData, options) {
  const requestHandler = async (event) => {
    const access = await verifyAccess(
      event.request.headers.get("Authorization"),
      options?.secret
    );
    if (!access)
      error(401);
    const apiData = await getApiData(event);
    return json(apiData, { headers: { "x-flags-sdk-version": version } });
  };
  return requestHandler;
}
export {
  createFlagsDiscoveryEndpoint,
  createHandle,
  decryptFlagDefinitions2 as decryptFlagDefinitions,
  decryptFlagValues2 as decryptFlagValues,
  decryptOverrides2 as decryptOverrides,
  encryptFlagDefinitions2 as encryptFlagDefinitions,
  encryptFlagValues2 as encryptFlagValues,
  encryptOverrides2 as encryptOverrides,
  flag,
  generatePermutations2 as generatePermutations,
  getProviderData,
  precompute2 as precompute
};
//# sourceMappingURL=sveltekit.js.map