{"version":3,"sources":["../src/next/index.ts","../src/next/overrides.ts","../src/next/precompute.ts","../src/next/is-internal-next-error.ts","../src/next/dedupe.ts","../src/next/create-flags-discovery-endpoint.ts"],"sourcesContent":["import { RequestCookies } from '@edge-runtime/cookies';\nimport {\n  type FlagDefinitionType,\n  type ProviderData,\n  reportValue,\n  type FlagDefinitionsType,\n} from '..';\nimport type {\n  Decide,\n  FlagDeclaration,\n  FlagParamsType,\n  Identify,\n  JsonValue,\n  Origin,\n} from '../types';\nimport type { Flag, PrecomputedFlag, PagesRouterFlag } from './types';\nimport { getOverrides } from './overrides';\nimport { normalizeOptions } from '../lib/normalize-options';\nimport { getPrecomputed } from './precompute';\nimport type { IncomingHttpHeaders } from 'node:http';\nimport {\n  type ReadonlyHeaders,\n  HeadersAdapter,\n} from '../spec-extension/adapters/headers';\nimport {\n  type ReadonlyRequestCookies,\n  RequestCookiesAdapter,\n} from '../spec-extension/adapters/request-cookies';\nimport { setSpanAttribute, trace } from '../lib/tracing';\nimport { internalReportValue } from '../lib/report-value';\nimport { isInternalNextError } from './is-internal-next-error';\n\nexport type { Flag } from './types';\n\nexport {\n  getPrecomputed,\n  combine,\n  serialize,\n  deserialize,\n  evaluate,\n  precompute,\n  generatePermutations,\n} from './precompute';\n\n// a map of (headers, flagKey, entitiesKey) => value\nconst evaluationCache = new WeakMap<\n  Headers | IncomingHttpHeaders,\n  Map</* flagKey */ string, Map</* entitiesKey */ string, any>>\n>();\n\nfunction getCachedValuePromise(\n  /**\n   * supports Headers for App Router and IncomingHttpHeaders for Pages Router\n   */\n  headers: Headers | IncomingHttpHeaders,\n  flagKey: string,\n  entitiesKey: string,\n): any {\n  const map = evaluationCache.get(headers)?.get(flagKey);\n  if (!map) return undefined;\n  return map.get(entitiesKey);\n}\n\nfunction setCachedValuePromise(\n  /**\n   * supports Headers for App Router and IncomingHttpHeaders for Pages Router\n   */\n  headers: Headers | IncomingHttpHeaders,\n  flagKey: string,\n  entitiesKey: string,\n  flagValue: any,\n): any {\n  const byHeaders = evaluationCache.get(headers);\n\n  if (!byHeaders) {\n    evaluationCache.set(\n      headers,\n      new Map([[flagKey, new Map([[entitiesKey, flagValue]])]]),\n    );\n    return;\n  }\n\n  const byFlagKey = byHeaders.get(flagKey);\n  if (!byFlagKey) {\n    byHeaders.set(flagKey, new Map([[entitiesKey, flagValue]]));\n    return;\n  }\n\n  byFlagKey.set(entitiesKey, flagValue);\n}\n\ntype IdentifyArgs = Parameters<\n  Exclude<FlagDeclaration<any, any>['identify'], undefined>\n>;\nconst transformMap = new WeakMap<IncomingHttpHeaders, Headers>();\nconst headersMap = new WeakMap<Headers, ReadonlyHeaders>();\nconst cookiesMap = new WeakMap<Headers, ReadonlyRequestCookies>();\nconst identifyArgsMap = new WeakMap<\n  Headers | IncomingHttpHeaders,\n  IdentifyArgs\n>();\n\n/**\n * Transforms IncomingHttpHeaders to Headers\n */\nfunction transformToHeaders(incomingHeaders: IncomingHttpHeaders): Headers {\n  const cached = transformMap.get(incomingHeaders);\n  if (cached !== undefined) return cached;\n\n  const headers = new Headers();\n  for (const [key, value] of Object.entries(incomingHeaders)) {\n    if (Array.isArray(value)) {\n      // If the value is an array, add each item separately\n      value.forEach((item) => headers.append(key, item));\n    } else if (value !== undefined) {\n      // If it's a single value, add it directly\n      headers.append(key, value);\n    }\n  }\n\n  transformMap.set(incomingHeaders, headers);\n  return headers;\n}\n\nfunction sealHeaders(headers: Headers): ReadonlyHeaders {\n  const cached = headersMap.get(headers);\n  if (cached !== undefined) return cached;\n\n  const sealed = HeadersAdapter.seal(headers);\n  headersMap.set(headers, sealed);\n  return sealed;\n}\n\nfunction sealCookies(headers: Headers): ReadonlyRequestCookies {\n  const cached = cookiesMap.get(headers);\n  if (cached !== undefined) return cached;\n\n  const sealed = RequestCookiesAdapter.seal(new RequestCookies(headers));\n  cookiesMap.set(headers, sealed);\n  return sealed;\n}\n\nfunction isIdentifyFunction<ValueType, EntitiesType>(\n  identify: FlagDeclaration<ValueType, EntitiesType>['identify'] | EntitiesType,\n): identify is FlagDeclaration<ValueType, EntitiesType>['identify'] {\n  return typeof identify === 'function';\n}\n\nasync function getEntities<ValueType, EntitiesType>(\n  identify: FlagDeclaration<ValueType, EntitiesType>['identify'] | EntitiesType,\n  dedupeCacheKey: Headers | IncomingHttpHeaders,\n  readonlyHeaders: ReadonlyHeaders,\n  readonlyCookies: ReadonlyRequestCookies,\n): Promise<EntitiesType | undefined> {\n  if (!identify) return undefined;\n  if (!isIdentifyFunction(identify)) return identify;\n\n  const args = identifyArgsMap.get(dedupeCacheKey);\n  if (args) return identify(...(args as [FlagParamsType]));\n\n  const nextArgs: IdentifyArgs = [\n    { headers: readonlyHeaders, cookies: readonlyCookies },\n  ];\n  identifyArgsMap.set(dedupeCacheKey, nextArgs);\n  return identify(...(nextArgs as [FlagParamsType]));\n}\n\nfunction getDecide<ValueType, EntitiesType>(\n  definition: FlagDeclaration<ValueType, EntitiesType>,\n): Decide<ValueType, EntitiesType> {\n  return function decide(params) {\n    if (typeof definition.decide === 'function') {\n      return definition.decide(params);\n    }\n    if (typeof definition.adapter?.decide === 'function') {\n      return definition.adapter.decide({ key: definition.key, ...params });\n    }\n    throw new Error(`flags: No decide function provided for ${definition.key}`);\n  };\n}\n\nfunction getIdentify<ValueType, EntitiesType>(\n  definition: FlagDeclaration<ValueType, EntitiesType>,\n): Identify<EntitiesType> {\n  return function identify(params) {\n    if (typeof definition.identify === 'function') {\n      return definition.identify(params);\n    }\n    if (typeof definition.adapter?.identify === 'function') {\n      return definition.adapter.identify(params);\n    }\n    return definition.identify;\n  };\n}\n\ntype Run<ValueType, EntitiesType> = (options: {\n  entities?: EntitiesType;\n  identify?:\n    | FlagDeclaration<ValueType, EntitiesType>['identify']\n    | EntitiesType;\n  /**\n   * For Pages Router only\n   */\n  request?: Parameters<PagesRouterFlag<ValueType, EntitiesType>>[0];\n}) => Promise<ValueType>;\n\nfunction getRun<ValueType, EntitiesType>(\n  definition: FlagDeclaration<ValueType, EntitiesType>,\n  decide: Decide<ValueType, EntitiesType>,\n): Run<ValueType, EntitiesType> {\n  // use cache to guarantee flags only decide once per request\n  return async function run(options): Promise<ValueType> {\n    let readonlyHeaders: ReadonlyHeaders;\n    let readonlyCookies: ReadonlyRequestCookies;\n    let dedupeCacheKey: Headers | IncomingHttpHeaders;\n\n    if (options.request) {\n      // pages router\n      const headers = transformToHeaders(options.request.headers);\n      readonlyHeaders = sealHeaders(headers);\n      readonlyCookies = sealCookies(headers);\n      dedupeCacheKey = options.request.headers;\n    } else {\n      // app router\n\n      // async import required as turbopack errors in Pages Router\n      // when next/headers is imported at the top-level\n      const { headers, cookies } = await import('next/headers');\n\n      const [headersStore, cookiesStore] = await Promise.all([\n        headers(),\n        cookies(),\n      ]);\n      readonlyHeaders = headersStore as ReadonlyHeaders;\n      readonlyCookies = cookiesStore as ReadonlyRequestCookies;\n      dedupeCacheKey = headersStore;\n    }\n\n    const overrides = await getOverrides(\n      readonlyCookies.get('vercel-flag-overrides')?.value,\n    );\n\n    // the flag is being used in app router\n    const entities = (await getEntities(\n      options.identify,\n      dedupeCacheKey,\n      readonlyHeaders,\n      readonlyCookies,\n    )) as EntitiesType | undefined;\n\n    // check cache\n    const entitiesKey = JSON.stringify(entities) ?? '';\n\n    const cachedValue = getCachedValuePromise(\n      readonlyHeaders,\n      definition.key,\n      entitiesKey,\n    );\n    if (cachedValue !== undefined) {\n      setSpanAttribute('method', 'cached');\n      const value = await cachedValue;\n      return value;\n    }\n\n    if (overrides && overrides[definition.key] !== undefined) {\n      setSpanAttribute('method', 'override');\n      const decision = overrides[definition.key] as ValueType;\n      setCachedValuePromise(\n        readonlyHeaders,\n        definition.key,\n        entitiesKey,\n        Promise.resolve(decision),\n      );\n      internalReportValue(definition.key, decision, {\n        reason: 'override',\n      });\n      return decision;\n    }\n\n    // We use an async iife to ensure we can catch both sync and async errors of\n    // the original decide function, as that one is not guaranted to be async.\n    //\n    // Also fall back to defaultValue when the decide function returns undefined or throws an error.\n    const decisionPromise = (async () => {\n      return decide({\n        // @ts-expect-error TypeScript will not be able to process `getPrecomputed` when added to `Decide`. It is, however, part of the `Adapter` type\n        defaultValue: definition.defaultValue,\n        headers: readonlyHeaders,\n        cookies: readonlyCookies,\n        entities,\n      });\n    })()\n      // catch errors in async \"decide\" functions\n      .then<ValueType, ValueType>(\n        (value) => {\n          if (value !== undefined) return value;\n          if (definition.defaultValue !== undefined)\n            return definition.defaultValue;\n          throw new Error(\n            `flags: Flag \"${definition.key}\" must have a defaultValue or a decide function that returns a value`,\n          );\n        },\n        (error: Error) => {\n          if (isInternalNextError(error)) throw error;\n\n          // try to recover if defaultValue is set\n          if (definition.defaultValue !== undefined) {\n            if (process.env.NODE_ENV === 'development') {\n              console.info(\n                `flags: Flag \"${definition.key}\" is falling back to its defaultValue`,\n              );\n            } else {\n              console.warn(\n                `flags: Flag \"${definition.key}\" is falling back to its defaultValue after catching the following error`,\n                error,\n              );\n            }\n            return definition.defaultValue;\n          }\n          console.warn(\n            `flags: Flag \"${definition.key}\" could not be evaluated`,\n          );\n          throw error;\n        },\n      );\n\n    setCachedValuePromise(\n      readonlyHeaders,\n      definition.key,\n      entitiesKey,\n      decisionPromise,\n    );\n\n    const decision = await decisionPromise;\n\n    if (definition.config?.reportValue !== false) {\n      // Only check `config.reportValue` for the result of `decide`.\n      // No need to check it for `override` since the client will have\n      // be short circuited in that case.\n      reportValue(definition.key, decision);\n    }\n\n    return decision;\n  };\n}\n\nfunction getOrigin<ValueType, EntitiesType>(\n  definition: FlagDeclaration<ValueType, EntitiesType>,\n): string | Origin | undefined {\n  if (definition.origin) return definition.origin;\n  if (typeof definition.adapter?.origin === 'function')\n    return definition.adapter.origin(definition.key);\n  return definition.adapter?.origin;\n}\n\n/**\n * Declares a feature flag.\n *\n * This a feature flag function. When that function is called it will call the flag's `decide` function and return the result.\n *\n * If an override set by Vercel Toolbar, or more precisely if the `vercel-flag-overrides` cookie, is present then the `decide` function will not be called and the value of the override will be returned instead.\n *\n * In both cases this function also calls the `reportValue` function of `flags` so the evaluated flag shows up in Runtime Logs and is available for use with Web Analytics custom server-side events.\n *\n *\n * @param definition - Information about the feature flag.\n * @returns - A feature flag declaration\n */\nexport function flag<\n  ValueType extends JsonValue = boolean | string | number,\n  EntitiesType = any,\n>(\n  definition: FlagDeclaration<ValueType, EntitiesType>,\n): Flag<ValueType, EntitiesType> {\n  const decide = getDecide<ValueType, EntitiesType>(definition);\n  const identify = getIdentify<ValueType, EntitiesType>(definition);\n  const run = getRun<ValueType, EntitiesType>(definition, decide);\n  const origin = getOrigin(definition);\n\n  const flag = trace(\n    async (...args: any[]) => {\n      // Default method, may be overwritten by `getPrecomputed` or `run`\n      // which is why we must not trace them directly in here,\n      // as the attribute should be part of the `flag` function.\n      setSpanAttribute('method', 'decided');\n\n      // the flag was precomputed, works for both App Router and Pages Router\n      if (typeof args[0] === 'string' && Array.isArray(args[1])) {\n        const [precomputedCode, precomputedGroup, secret] = args as Parameters<\n          PrecomputedFlag<ValueType, EntitiesType>\n        >;\n        if (precomputedCode && precomputedGroup) {\n          setSpanAttribute('method', 'precomputed');\n          return getPrecomputed(\n            flag,\n            precomputedGroup,\n            precomputedCode,\n            secret,\n          );\n        }\n      }\n\n      // check if we're using the flag in pages router\n      //\n      // ideally we'd check args[0] instanceof IncomingMessage, but that leads\n      // to build time errors in the host application due to Edge Runtime,\n      // so we check for headers on the first arg instead, which indicates an\n      // IncomingMessage\n      if (args[0] && typeof args[0] === 'object' && 'headers' in args[0]) {\n        const [request] = args as Parameters<\n          PagesRouterFlag<ValueType, EntitiesType>\n        >;\n        return run({ identify, request });\n      }\n\n      // the flag is being used in app router\n      return run({ identify, request: undefined });\n    },\n    {\n      name: 'flag',\n      isVerboseTrace: false,\n      attributes: { key: definition.key },\n    },\n  ) as Flag<ValueType, EntitiesType>;\n\n  flag.key = definition.key;\n  flag.defaultValue = definition.defaultValue;\n  flag.origin = origin;\n  flag.options = normalizeOptions<ValueType>(definition.options);\n  flag.description = definition.description;\n  flag.identify = identify\n    ? trace(identify, {\n        isVerboseTrace: false,\n        name: 'identify',\n        attributes: { key: definition.key },\n      })\n    : identify;\n  flag.decide = trace(decide, {\n    isVerboseTrace: false,\n    name: 'decide',\n    attributes: { key: definition.key },\n  });\n  flag.run = trace(run, {\n    isVerboseTrace: false,\n    name: 'run',\n    attributes: { key: definition.key },\n  });\n\n  return flag;\n}\n\nexport type KeyedFlagDefinitionType = { key: string } & FlagDefinitionType;\n\n// -----------------------------------------------------------------------------\n\n/**\n * Takes an object whose values are feature flag declarations and\n * turns them into ProviderData to be returned through `/.well-known/vercel/flags`.\n */\nexport function getProviderData(\n  flags: Record<\n    string,\n    // accept an unknown array\n    KeyedFlagDefinitionType | readonly unknown[]\n  >,\n): ProviderData {\n  const definitions = Object.values(flags)\n    // filter out precomputed arrays\n    .filter((i): i is KeyedFlagDefinitionType => !Array.isArray(i))\n    .reduce<FlagDefinitionsType>((acc, d) => {\n      // maps the existing type from the facet definitions to the type\n      // the toolbar expects\n      acc[d.key] = {\n        options: d.options,\n        origin: d.origin,\n        description: d.description,\n        defaultValue: d.defaultValue,\n        declaredInCode: true,\n      } satisfies FlagDefinitionType;\n      return acc;\n    }, {});\n\n  return { definitions, hints: [] };\n}\n\nexport { dedupe } from './dedupe';\nexport { createFlagsDiscoveryEndpoint } from './create-flags-discovery-endpoint';\n","import { decryptOverrides } from '..';\nimport { memoizeOne } from '../lib/async-memoize-one';\n\nconst memoizedDecrypt = memoizeOne(\n  (text: string) => decryptOverrides(text),\n  (a, b) => a[0] === b[0], // only the first argument gets compared\n  { cachePromiseRejection: true },\n);\n\nexport async function getOverrides(cookie: string | undefined) {\n  if (typeof cookie === 'string' && cookie !== '') {\n    const cookieOverrides = await memoizedDecrypt(cookie);\n    return cookieOverrides ?? null;\n  }\n\n  return null;\n}\n","import { Flag } from './types';\nimport type { JsonValue } from '..';\nimport * as s from '../lib/serialization';\n\ntype FlagsArray = readonly Flag<any, any>[];\ntype ValuesArray = readonly any[];\n\n/**\n * Resolves a list of flags\n * @param flags - list of flags\n * @returns - an array of evaluated flag values with one entry per flag\n */\nexport async function evaluate<T extends FlagsArray>(\n  flags: T,\n): Promise<{ [K in keyof T]: Awaited<ReturnType<T[K]>> }> {\n  return Promise.all(flags.map((flag) => flag())) as Promise<{\n    [K in keyof T]: Awaited<ReturnType<T[K]>>;\n  }>;\n}\n\n/**\n * Evaluate a list of feature flags and generate a signed string representing their values.\n *\n * This convenience function call combines `evaluate` and `serialize`.\n *\n * @param flags - list of flags\n * @returns - a string representing evaluated flags\n */\nexport async function precompute<T extends FlagsArray>(\n  flags: T,\n): Promise<string> {\n  const values = await evaluate(flags);\n  return serialize(flags, values);\n}\n\n/**\n * Combines flag declarations with values.\n * @param flags - flag declarations\n * @param values - flag values\n * @returns - A record where the keys are flag keys and the values are flag values.\n */\nexport function combine(flags: FlagsArray, values: ValuesArray) {\n  return Object.fromEntries(flags.map((flag, i) => [flag.key, values[i]]));\n}\n\n/**\n * Takes a list of feature flag declarations and their values and turns them into a short, signed string.\n *\n * The returned string is signed to avoid enumeration attacks.\n *\n * When a feature flag's `options` contains the value the flag resolved to, then the encoding will store it's index only, leading to better compression. Boolean values and null are compressed even when the options are not declared on the flag.\n *\n * @param flags - A list of feature flags\n * @param values - A list of the values of the flags declared in ´flags`\n * @param secret - The secret to use for signing the result\n * @returns - A short string representing the values.\n */\nexport async function serialize(\n  flags: FlagsArray,\n  values: ValuesArray,\n  secret: string | undefined = process.env.FLAGS_SECRET,\n) {\n  if (!secret) {\n    throw new Error('flags: Can not serialize due to missing secret');\n  }\n\n  return s.serialize(combine(flags, values), flags, secret);\n}\n\n/**\n * Decodes all flags given the list of flags used to encode. Returns an object consisting of each flag's key and its resolved value.\n * @param flags - Flags used when `code` was generated by `precompute` or `serialize`.\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for signing the result\n * @returns - An object consisting of each flag's key and its resolved value.\n */\nexport async function deserialize(\n  flags: FlagsArray,\n  code: string,\n  secret: string | undefined = process.env.FLAGS_SECRET,\n) {\n  if (!secret) {\n    throw new Error('flags: Can not serialize due to missing secret');\n  }\n\n  return s.deserialize(code, flags, secret);\n}\n\n/**\n * Decodes the value of one or multiple flags given the list of flags used to encode and the code.\n *\n * @param flag - Flag or list of flags to decode\n * @param precomputeFlags - Flags used when `code` was generated by `serialize`\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for verifying the signature\n */\nexport async function getPrecomputed<T extends JsonValue>(\n  flag: Flag<T, any>,\n  precomputeFlags: FlagsArray,\n  code: string,\n  secret?: string,\n): Promise<T>;\n\n/**\n * Decodes the value of one or multiple flags given the list of flags used to encode and the code.\n *\n * @param flag - Flag or list of flags to decode\n * @param precomputeFlags - Flags used when `code` was generated by `serialize`\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for verifying the signature\n */\nexport async function getPrecomputed<\n  T extends JsonValue,\n  K extends readonly Flag<T, any>[],\n>(\n  flags: readonly [...K],\n  precomputeFlags: FlagsArray,\n  code: string,\n  secret?: string,\n): Promise<{ [P in keyof K]: K[P] extends Flag<infer U, any> ? U : never }>;\n\n/**\n * Decodes the value of one or multiple flags given the list of flags used to encode and the code.\n *\n * @param flag - Flag or list of flags to decode\n * @param precomputeFlags - Flags used when `code` was generated by `serialize`\n * @param code - The code returned from `serialize`\n * @param secret - The secret to use for verifying the signature\n */\nexport async function getPrecomputed<T extends JsonValue>(\n  flagOrFlags: Flag<T, any> | readonly Flag<T, any>[],\n  precomputeFlags: FlagsArray,\n  code: string,\n  secret: string | undefined = process.env.FLAGS_SECRET,\n): Promise<any> {\n  if (!secret) {\n    throw new Error(\n      'flags: getPrecomputed was called without a secret. Please set FLAGS_SECRET environment variable.',\n    );\n  }\n\n  const flagSet = await deserialize(precomputeFlags, code, secret);\n\n  if (Array.isArray(flagOrFlags)) {\n    // Handle case when an array of flags is passed\n    return flagOrFlags.map((flag) => flagSet[flag.key]);\n  } else {\n    // Handle case when a single flag is passed\n    return flagSet[(flagOrFlags as Flag<T, any>).key];\n  }\n}\n\n// see https://stackoverflow.com/a/44344803\nfunction* cartesianIterator<T>(items: T[][]): Generator<T[]> {\n  const remainder = items.length > 1 ? cartesianIterator(items.slice(1)) : [[]];\n  for (let r of remainder) for (let h of items.at(0)!) yield [h, ...r];\n}\n\n/**\n * Generates all permutations given a list of feature flags based on the options declared on each flag.\n * @param flags - The list of feature flags\n * @param filter - An optional filter function which gets called with each permutation.\n * @param secret - The secret sign the generated permutation with\n * @returns An array of strings representing each permutation\n */\nexport async function generatePermutations(\n  flags: FlagsArray,\n  filter: ((permutation: Record<string, JsonValue>) => boolean) | null = null,\n  secret: string = process.env.FLAGS_SECRET!,\n): Promise<string[]> {\n  if (!secret) {\n    throw new Error(\n      'flags: generatePermutations was called without a secret. Please set FLAGS_SECRET environment variable.',\n    );\n  }\n\n  const options = flags.map((flag) => {\n    // infer boolean permutations if you don't declare any options.\n    //\n    // to explicitly opt out you need to use \"filter\"\n    if (!flag.options) return [false, true];\n    return flag.options.map((option) => option.value);\n  });\n\n  const list: Record<string, JsonValue>[] = [];\n\n  for (const permutation of cartesianIterator(options)) {\n    const permObject = permutation.reduce<Record<string, JsonValue>>(\n      (acc, value, index) => {\n        acc[flags[index]!.key] = value;\n        return acc;\n      },\n      {},\n    );\n    if (!filter || filter(permObject)) list.push(permObject);\n  }\n\n  return Promise.all(list.map((values) => s.serialize(values, flags, secret)));\n}\n","// This is a temporary workaround until the appropriate mechanism is added to\n// Next.js to detect an error that should not be caught. This symbol is defined\n// in React, but is not exported, so we have to define it here.\n//\n// See: https://github.com/facebook/react/blob/493610f299ddf7d06e147e60dc4f2b97482982d2/packages/shared/ReactSymbols.js#L52\n//\nconst REACT_POSTPONE_TYPE: symbol = Symbol.for('react.postpone');\n\nfunction isPostpone(error: unknown): boolean {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    '$$typeof' in error &&\n    error.$$typeof === REACT_POSTPONE_TYPE\n  );\n}\n\n/**\n * Determines if an error is an error that Next/React uses internally to signal\n * a particular behavior, and not an error that should be caught by user-code.\n * This is a stop-gap until a better solution like `unstable_rethrow` lands.\n * This is a brittle solution and should be removed as soon as a better solution becomes available,\n * as it relies on internal implementation details of Next.js.\n * Context: https://github.com/vercel/next.js/discussions/64076\n * @param error - The error to check\n * @returns True if the error is an error that shouldn't be treated as an error.\n */\nexport function isInternalNextError(error: unknown): boolean {\n  if (isPostpone(error)) return true;\n\n  // Next.js internal errors attach a special message to the `digest` property.\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false;\n  }\n\n  // Redirect errors contain additional information delimited by a semicolon\n  // We only care about the error code, which is the first part of the digest\n  const errorCode = error.digest.split(';')[0];\n\n  return (\n    errorCode === 'NEXT_REDIRECT' ||\n    errorCode === 'DYNAMIC_SERVER_USAGE' ||\n    errorCode === 'BAILOUT_TO_CLIENT_SIDE_RENDERING' ||\n    errorCode === 'NEXT_NOT_FOUND'\n  );\n}\n","enum Status {\n  UNTERMINATED = 0,\n  TERMINATED = 1,\n  ERRORED = 2,\n}\n\ntype CacheNode<T> = {\n  s: Status;\n  v: T | undefined | unknown;\n  o: WeakMap<Function | Object, CacheNode<T>> | null;\n  p: Map<\n    string | number | null | undefined | symbol | boolean,\n    CacheNode<T>\n  > | null;\n};\n\nfunction createCacheNode<T>(): CacheNode<T> {\n  return {\n    s: Status.UNTERMINATED,\n    v: undefined,\n    o: null,\n    p: null,\n  };\n}\n\n/**\n * A middleware-friendly version of React.cache.\n *\n * Given the same arguments, the function wrapped by this function will only ever run once for the duration of a request.\n *\n * React.cache should not be used in middleware as it would bring all of react\n * into middleware, thus leading to an unnecessarily large middleware bundle.\n *\n * This function is a polyfill that will eventually land in Next.js itself,\n * at which point it will be removed from `flags/next`.\n *\n * This function will turn any sync function async, since we rely on the\n * headers() API to dedupe, which is async.\n */\nexport function dedupe<A extends Array<unknown>, T>(\n  fn: (...args: A) => T | Promise<T>,\n): (...args: A) => Promise<T> {\n  const requestStore = new WeakMap<Headers, CacheNode<T>>();\n\n  return async function (this: unknown, ...args: A): Promise<T> {\n    // async import required as turbopack errors in Pages Router\n    // when next/headers is imported at the top-level\n    const { headers } = await import('next/headers');\n\n    const h = await headers();\n    let cacheNode = requestStore.get(h);\n    if (!cacheNode) {\n      cacheNode = createCacheNode<T>();\n      requestStore.set(h, cacheNode);\n    }\n\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      if (\n        typeof arg === 'function' ||\n        (typeof arg === 'object' && arg !== null)\n      ) {\n        let objectCache: WeakMap<Function | Object, CacheNode<T>> | null =\n          cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = new WeakMap();\n        }\n        const objectNode = objectCache.get(arg);\n        if (objectNode === undefined) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        let primitiveCache: Map<unknown, CacheNode<T>> | null = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = new Map();\n        }\n        const primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === undefined) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n\n    if (cacheNode.s === Status.TERMINATED) {\n      return cacheNode.v as T;\n    }\n    if (cacheNode.s === Status.ERRORED) {\n      throw cacheNode.v;\n    }\n\n    try {\n      const result = fn.apply(this, args);\n      cacheNode.s = Status.TERMINATED;\n      cacheNode.v = result;\n      return result;\n    } catch (error) {\n      cacheNode.s = Status.ERRORED;\n      cacheNode.v = error;\n      throw error;\n    }\n  };\n}\n","// Must not import anything other than types from next/server, as importing\n// the real next/server would prevent flags/next from working in Pages Router.\nimport type { NextRequest } from 'next/server';\nimport { ApiData } from '../types';\nimport { verifyAccess } from '../lib/verify-access';\nimport { version } from '..';\n\n/**\n * Creates the Flags Discovery Endpoint for Next.js, which is a well-known endpoint used\n * by Flags Explorer to discover the flags of your application.\n *\n * @param getApiData a function returning the API data\n * @param options accepts a secret\n * @returns a Next.js Route Handler\n */\nexport function createFlagsDiscoveryEndpoint(\n  getApiData: (request: NextRequest) => Promise<ApiData> | ApiData,\n  options?: {\n    secret?: string | undefined;\n  },\n) {\n  return async (request: NextRequest): Promise<Response> => {\n    const access = await verifyAccess(\n      request.headers.get('Authorization'),\n      options?.secret,\n    );\n    if (!access) return Response.json(null, { status: 401 });\n\n    const apiData = await getApiData(request);\n    return new Response(JSON.stringify(apiData), {\n      headers: {\n        'x-flags-sdk-version': version,\n        'content-type': 'application/json',\n      },\n    });\n  };\n}\n"],"mappings":"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","names":["flag","serialize","deserialize","decision","flag"]}