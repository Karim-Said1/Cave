{"version":3,"sources":["../package.json","../src/lib/tracing.ts","../src/lib/crypto.ts","../src/lib/verify-access.ts","../src/lib/report-value.ts","../src/spec-extension/adapters/reflect.ts","../src/spec-extension/adapters/headers.ts","../src/spec-extension/adapters/request-cookies.ts","../src/lib/merge-provider-data.ts"],"sourcesContent":["{\n  \"name\": \"flags\",\n  \"version\": \"4.0.0\",\n  \"description\": \"Flags SDK by Vercel - The feature flags toolkit for Next.js and SvelteKit\",\n  \"keywords\": [\n    \"feature flags\",\n    \"Next.js\",\n    \"react\",\n    \"toolbar\",\n    \"overrides\",\n    \"SvelteKit\"\n  ],\n  \"homepage\": \"https://flags-sdk.dev\",\n  \"bugs\": {\n    \"url\": \"https://github.com/vercel/flags/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/vercel/flags.git\"\n  },\n  \"license\": \"MIT\",\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    },\n    \"./next\": {\n      \"import\": \"./dist/next.js\",\n      \"require\": \"./dist/next.cjs\"\n    },\n    \"./analytics\": {\n      \"import\": \"./dist/analytics.js\",\n      \"require\": \"./dist/analytics.cjs\"\n    },\n    \"./react\": {\n      \"import\": \"./dist/react.js\",\n      \"require\": \"./dist/react.cjs\"\n    },\n    \"./sveltekit\": {\n      \"svelte\": \"./dist/sveltekit.js\",\n      \"import\": \"./dist/sveltekit.js\",\n      \"require\": \"./dist/sveltekit.cjs\"\n    }\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"*\": [\n        \"dist/*.d.ts\",\n        \"dist/*.d.cts\"\n      ],\n      \"next\": [\n        \"dist/next.d.ts\",\n        \"dist/next.d.cts\"\n      ],\n      \"react\": [\n        \"dist/react.d.ts\",\n        \"dist/react.d.cts\"\n      ],\n      \"sveltekit\": [\n        \"dist/sveltekit.d.ts\",\n        \"dist/sveltekit.d.cts\"\n      ]\n    }\n  },\n  \"files\": [\n    \"dist\",\n    \"CHANGELOG.md\"\n  ],\n  \"scripts\": {\n    \"attw\": \"attw --pack .\",\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch --clean=false\",\n    \"eslint\": \"eslint-runner\",\n    \"eslint:fix\": \"eslint-runner --fix\",\n    \"test\": \"vitest --run\",\n    \"test:watch\": \"vitest\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@edge-runtime/cookies\": \"^5.0.2\",\n    \"jose\": \"^5.2.1\"\n  },\n  \"devDependencies\": {\n    \"@arethetypeswrong/cli\": \"0.17.3\",\n    \"@types/node\": \"20.11.17\",\n    \"@types/react\": \"18.2.55\",\n    \"@vitejs/plugin-react\": \"4.2.1\",\n    \"eslint-config-custom\": \"workspace:*\",\n    \"msw\": \"2.6.4\",\n    \"next\": \"15.1.4\",\n    \"react\": \"canary\",\n    \"tsconfig\": \"workspace:*\",\n    \"tsup\": \"8.0.1\",\n    \"typescript\": \"5.6.3\",\n    \"vite\": \"5.1.1\",\n    \"vitest\": \"1.4.0\"\n  },\n  \"peerDependencies\": {\n    \"@opentelemetry/api\": \"^1.7.0\",\n    \"@sveltejs/kit\": \"*\",\n    \"next\": \"*\",\n    \"react\": \"*\",\n    \"react-dom\": \"*\"\n  },\n  \"peerDependenciesMeta\": {\n    \"@opentelemetry/api\": {\n      \"optional\": true\n    },\n    \"@sveltejs/kit\": {\n      \"optional\": true\n    },\n    \"next\": {\n      \"optional\": true\n    },\n    \"react\": {\n      \"optional\": true\n    },\n    \"react-dom\": {\n      \"optional\": true\n    }\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  }\n}\n","import type {\n  Tracer,\n  Attributes,\n  TracerProvider,\n  AttributeValue,\n} from '@opentelemetry/api';\nimport { name as pkgName, version } from '../../package.json';\nimport { AsyncLocalStorage } from 'async_hooks';\n\n// Use a symbol to avoid having global variable that is scoped to this file,\n// as it can lead to issues with cjs and mjs being used at the same time.\nconst vercelFlagsTraceSymbol = Symbol.for('flags:global-trace');\n\n/**\n * Allows setting the `@opentelemetry/api` tracer provider to generate traces\n * for `flags` operations.\n */\nexport function setTracerProvider(tracer: TracerProvider): void {\n  Reflect.set(globalThis, vercelFlagsTraceSymbol, tracer);\n}\n\nfunction getTracer(): Tracer | undefined {\n  const maybeTraceApi = Reflect.get(globalThis, vercelFlagsTraceSymbol) as\n    | undefined\n    | TracerProvider;\n  return maybeTraceApi?.getTracer(pkgName, version);\n}\n\nfunction isPromise<T>(p: unknown): p is Promise<T> {\n  return (\n    p !== null &&\n    typeof p === 'object' &&\n    'then' in p &&\n    typeof p.then === 'function'\n  );\n}\n\nconst spanContext = new AsyncLocalStorage<Map<string, AttributeValue>>();\n\nexport function setSpanAttribute(name: string, value: AttributeValue) {\n  spanContext.getStore()?.set(name, value);\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- bc */\nexport function trace<F extends (...args: any) => any>(\n  fn: F,\n  options: {\n    name: string;\n    /** Defaults to `true`. If set to `false`, it'll trace regardless of `VERCEL_FLAGS_TRACE_VERBOSE`. */\n    isVerboseTrace?: boolean;\n    attributes?: Attributes;\n    attributesSuccess?: (\n      result: ReturnType<F> extends PromiseLike<infer U> ? U : ReturnType<F>,\n    ) => Attributes;\n    attributesError?: (error: Error) => Attributes;\n  } = {\n    name: fn.name,\n  },\n): F {\n  const traced = function (this: unknown, ...args: unknown[]): unknown {\n    const tracer = getTracer();\n    if (!tracer) return fn.apply(this, args);\n\n    const shouldTrace =\n      process.env.VERCEL_FLAGS_TRACE_VERBOSE === 'true' ||\n      options.isVerboseTrace === false;\n    if (!shouldTrace) return fn.apply(this, args);\n\n    return spanContext.run(new Map(), () =>\n      tracer.startActiveSpan(options.name, (span) => {\n        if (options.attributes) span.setAttributes(options.attributes);\n\n        try {\n          const result = fn.apply(this, args);\n\n          if (isPromise(result)) {\n            result\n              .then((value) => {\n                if (options.attributesSuccess) {\n                  span.setAttributes(\n                    options.attributesSuccess(\n                      value as ReturnType<F> extends PromiseLike<infer U>\n                        ? U\n                        : ReturnType<F>,\n                    ),\n                  );\n                }\n\n                spanContext.getStore()?.forEach((value, key) => {\n                  span.setAttribute(key, value);\n                });\n\n                span.setStatus({ code: 1 }); // 1 = Ok\n                span.end();\n              })\n              .catch((error) => {\n                if (options.attributesError) {\n                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n                  span.setAttributes(options.attributesError(error));\n                }\n\n                span.setStatus({\n                  code: 2, // 2 = Error\n                  message: error instanceof Error ? error.message : undefined,\n                });\n\n                spanContext.getStore()?.forEach((value, key) => {\n                  span.setAttribute(key, value);\n                });\n\n                span.end();\n              });\n          } else {\n            if (options.attributesSuccess) {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- k\n              span.setAttributes(options.attributesSuccess(result));\n            }\n\n            spanContext.getStore()?.forEach((value, key) => {\n              span.setAttribute(key, value);\n            });\n\n            span.setStatus({ code: 1 }); // 1 = Ok\n            span.end();\n          }\n\n          return result as unknown;\n        } catch (error: any) {\n          if (options.attributesError) {\n            span.setAttributes(options.attributesError(error as Error));\n          }\n\n          span.setStatus({\n            code: 2, // 2 = Error\n            message: error instanceof Error ? error.message : undefined,\n          });\n\n          spanContext.getStore()?.forEach((value, key) => {\n            span.setAttribute(key, value);\n          });\n\n          span.end();\n\n          throw error;\n        }\n      }),\n    );\n  };\n\n  return traced as unknown as F;\n}\n/* eslint-enable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any -- k */\n","/**\n * All JWEs created by crypto functions will typically use the same secret.\n *\n * It is vital that each decrypt function ensures the JWE was created for that\n * specific purpose, as the output of one encrypt function could otherwise be\n * used as the input to another decrypt function.\n */\nimport { base64url, jwtDecrypt, EncryptJWT } from 'jose';\nimport {\n  FlagDefinitionsType,\n  FlagOverridesType,\n  FlagValuesType,\n} from '../types';\n\ntype ExpirationTime = string | number | Date;\ntype PurposeClaim = 'overrides' | 'values' | 'definitions' | 'proof';\ntype Purpose = string | string[];\n\n/**\n * Checks if a purpose claim matches the expected purpose.\n *\n * @param pur - The purpose claim to check, can be a string or array of strings\n * @param expectedPurpose - The expected purpose to match against\n * @returns True if the purpose matches the expected purpose, false otherwise\n */\nconst hasPurpose = (pur: Purpose, expectedPurpose: PurposeClaim): boolean => {\n  return Array.isArray(pur)\n    ? pur.includes(expectedPurpose)\n    : pur === expectedPurpose;\n};\n\n/**\n * Encrypts data into a JSON Web Encryption (JWE) token.\n *\n * @param payload - The data to encrypt\n * @param secret - The encryption secret (must be a 256-bit key)\n * @param expirationTime - When the encrypted data should expire\n * @returns A promise resolving to the encrypted JWE string\n * @throws Error if the secret is invalid\n */\nasync function encryptJwe<T extends object = Record<string, unknown>>(\n  payload: T,\n  secret: string,\n  expirationTime: ExpirationTime,\n): Promise<string> {\n  const encodedSecret = base64url.decode(secret);\n\n  if (encodedSecret.length !== 32) {\n    throw new Error(\n      'flags: Invalid secret, it must be a 256-bit key (32 bytes)',\n    );\n  }\n\n  return new EncryptJWT(payload as Record<string, unknown>)\n    .setExpirationTime(expirationTime)\n    .setProtectedHeader({ alg: 'dir', enc: 'A256GCM' })\n    .encrypt(encodedSecret);\n}\n\n/**\n * Decrypts a JWE token and verifies its contents.\n *\n * @param text - The encrypted JWE token string\n * @param verify - A function to verify the decrypted payload is valid\n * @param secret - The decryption secret (must be a 256-bit key)\n * @returns A promise resolving to the decrypted data or undefined if invalid\n * @throws Error if the secret is invalid\n */\nasync function decryptJwe<T extends string | object = Record<string, unknown>>(\n  text: string,\n  verify: (payload: T) => boolean,\n  secret: string,\n): Promise<T | undefined> {\n  if (typeof text !== 'string') return;\n\n  const encodedSecret = base64url.decode(secret);\n\n  if (encodedSecret.length !== 32) {\n    throw new Error(\n      'flags: Invalid secret, it must be a 256-bit key (32 bytes)',\n    );\n  }\n\n  try {\n    const { payload } = await jwtDecrypt(text, encodedSecret);\n    const decoded = payload as T;\n    return verify(decoded) ? decoded : undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Encrypts flag overrides data.\n *\n * @param overrides - The flag overrides to encrypt\n * @param secret - The encryption secret (defaults to FLAGS_SECRET env var)\n * @param expirationTime - When the encrypted data should expire (defaults to 1 year)\n * @returns A promise resolving to the encrypted JWE string\n * @throws Error if the secret is missing or invalid\n */\nexport async function encryptOverrides(\n  overrides: FlagOverridesType,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n  expirationTime: ExpirationTime = '1y',\n) {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  return encryptJwe({ o: overrides, pur: 'overrides' }, secret, expirationTime);\n}\n\n/**\n * Decrypts and validates flag overrides data.\n *\n * @param encryptedData - The encrypted JWE token string\n * @param secret - The decryption secret (defaults to FLAGS_SECRET env var)\n * @returns A promise resolving to the decrypted flag overrides or undefined if invalid\n * @throws Error if the secret is missing or invalid\n */\nexport async function decryptOverrides(\n  encryptedData: string,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n): Promise<FlagOverridesType | undefined> {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  const contents = await decryptJwe<{\n    o: FlagOverridesType;\n    pur: Purpose;\n  }>(\n    encryptedData,\n    (data) => hasPurpose(data.pur, 'overrides') && Object.hasOwn(data, 'o'),\n    secret,\n  );\n  return contents?.o;\n}\n\n/**\n * Encrypts flag values data.\n *\n * @param flagValues - The flag values to encrypt\n * @param secret - The encryption secret (defaults to FLAGS_SECRET env var)\n * @param expirationTime - When the encrypted data should expire (defaults to 1 year)\n * @returns A promise resolving to the encrypted JWE string\n * @throws Error if the secret is missing or invalid\n */\nexport async function encryptFlagValues(\n  flagValues: FlagValuesType,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n  expirationTime: ExpirationTime = '1y',\n) {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  return encryptJwe({ v: flagValues, pur: 'values' }, secret, expirationTime);\n}\n\n/**\n * Decrypts and validates flag values data.\n *\n * @param encryptedData - The encrypted JWE token string\n * @param secret - The decryption secret (defaults to FLAGS_SECRET env var)\n * @returns A promise resolving to the decrypted flag values or undefined if invalid\n * @throws Error if the secret is missing or invalid\n */\nexport async function decryptFlagValues(\n  encryptedData: string,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n): Promise<FlagValuesType | undefined> {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  const contents = await decryptJwe<{\n    v: FlagValuesType;\n    pur: Purpose;\n  }>(\n    encryptedData,\n    (data) => hasPurpose(data.pur, 'values') && Object.hasOwn(data, 'v'),\n    secret,\n  );\n  return contents?.v;\n}\n\n/**\n * Encrypts flag definitions data.\n *\n * @param flagDefinitions - The flag definitions to encrypt\n * @param secret - The encryption secret (defaults to FLAGS_SECRET env var)\n * @param expirationTime - When the encrypted data should expire (defaults to 1 year)\n * @returns A promise resolving to the encrypted JWE string\n * @throws Error if the secret is missing or invalid\n */\nexport async function encryptFlagDefinitions(\n  flagDefinitions: FlagDefinitionsType,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n  expirationTime: ExpirationTime = '1y',\n) {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  return encryptJwe(\n    { d: flagDefinitions, pur: 'definitions' },\n    secret,\n    expirationTime,\n  );\n}\n\n/**\n * Decrypts and validates flag definitions data.\n *\n * @param encryptedData - The encrypted JWE token string\n * @param secret - The decryption secret (defaults to FLAGS_SECRET env var)\n * @returns A promise resolving to the decrypted flag definitions or undefined if invalid\n * @throws Error if the secret is missing or invalid\n */\nexport async function decryptFlagDefinitions(\n  encryptedData: string,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n): Promise<FlagDefinitionsType | undefined> {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  const contents = await decryptJwe<{\n    d: FlagDefinitionsType;\n    pur: string;\n  }>(\n    encryptedData,\n    (data) => data.pur === 'definitions' && Object.hasOwn(data, 'd'),\n    secret,\n  );\n  return contents?.d;\n}\n\n/**\n * Creates an access proof token.\n *\n * @param secret - The encryption secret (defaults to FLAGS_SECRET env var)\n * @param expirationTime - When the token should expire (defaults to 1 year)\n * @returns A promise resolving to the encrypted access proof token\n * @throws Error if the secret is missing or invalid\n */\nexport async function createAccessProof(\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n  expirationTime: ExpirationTime = '1y',\n) {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  return encryptJwe({ pur: 'proof' }, secret, expirationTime);\n}\n\n/**\n * Verifies an access proof token is valid.\n *\n * @param encryptedData - The encrypted access proof token\n * @param secret - The decryption secret (defaults to FLAGS_SECRET env var)\n * @returns A promise resolving to a boolean indicating if the token is valid\n * @throws Error if the secret is missing or invalid\n */\nexport async function verifyAccessProof(\n  encryptedData: string,\n  secret: string | undefined = process?.env?.FLAGS_SECRET,\n) {\n  if (!secret) throw new Error('flags: Missing FLAGS_SECRET');\n  const contents = await decryptJwe<{\n    pur: string;\n  }>(encryptedData, (data) => hasPurpose(data.pur, 'proof'), secret);\n\n  return Boolean(contents);\n}\n","import { verifyAccessProof } from './crypto';\nimport { trace } from './tracing';\n\n/**\n * This function lets you verify whether a request to your application's .well-known/vercel/flags endpoint was made by the toolbar.\n * You can use verifyAccess to keep this endpoint private, to avoid public access of your feature flag definitions through that endpoint.\n *\n * @example Using verifyAccess in .well-known/vercel/flags to verify access and respond with unencrypted data.\n * ```\n *  import { type NextRequest, NextResponse } from \"next/server\";\n *  import { verifyAccess } from \"flags\";\n *\n *  export async function GET(request: NextRequest) {\n *    const access = await verifyAccess(request.headers.get(\"Authorization\"));\n *    if (!access) return NextResponse.json(null, { status: 401 });\n *\n *    return NextResponse.json({ definitions: {} })\n *  }\n * ```\n * @param authHeader the Authorization header to check\n * @param secret the FLAGS_SECRET\n * @returns True when the authorization header was valid\n */\nexport const verifyAccess = trace(\n  async function verifyAccess(\n    // App Router returns null when a header is not defined\n    // Pages Router returns undefined when a header is not defined\n    // We support both so the API is slim in both cases\n    authHeader: string | null | undefined,\n    secret: string | undefined = process?.env?.FLAGS_SECRET,\n  ) {\n    if (!authHeader) return false;\n    if (!secret)\n      throw new Error(\n        'flags: verifyAccess was called without a secret. Please set FLAGS_SECRET environment variable.',\n      );\n\n    const valid = await verifyAccessProof(\n      authHeader.replace(/^Bearer /i, ''),\n      secret,\n    );\n\n    return valid;\n  },\n  {\n    isVerboseTrace: false,\n    name: 'verifyAccess',\n  },\n);\n","import { version } from '../../package.json';\n\n/**\n * This function lets you report the value of a resolved flag, which will make it available when viewing Monitoring, Logs, Analytics and Speed Insights on Vercel.\n * It's important to note that this only has effects when running on Vercel in a preview or production environments, but not during local development.\n *\n * @example Using `reportValue` to report a flag value.\n * ```\n *  import { type NextRequest, NextResponse } from \"next/server\";\n *  import { reportValue } from 'flags';\n *\n *  export async function GET(request: NextRequest) {\n *    reportValue('my-flag', true);\n *    return NextResponse.json({});\n *  }\n * ```\n *\n * @param key the name of the flag\n * @param value the resolved value of the flag\n */\nexport function reportValue(key: string, value: unknown) {\n  const symbol = Symbol.for('@vercel/request-context');\n  const ctx = Reflect.get(globalThis, symbol)?.get();\n  ctx?.flags?.reportValue(key, value, {\n    sdkVersion: version,\n  });\n}\n\n/**\n * Only used interally for now.\n */\nexport function internalReportValue(\n  key: string,\n  value: unknown,\n  data: {\n    originProjectId?: string;\n    originProvider?: 'vercel';\n    reason?: 'override';\n  },\n) {\n  const symbol = Symbol.for('@vercel/request-context');\n  const ctx = Reflect.get(globalThis, symbol)?.get();\n  ctx?.flags?.reportValue(key, value, {\n    sdkVersion: version,\n    ...data,\n  });\n}\n","// copied from Next.js, and reduced\n// https://github.com/vercel/next.js/tree/canary/packages/next/src/server/web/spec-extension\nexport class ReflectAdapter {\n  static get<T extends object>(\n    target: T,\n    prop: string | symbol,\n    receiver: unknown,\n  ): any {\n    const value = Reflect.get(target, prop, receiver);\n    if (typeof value === 'function') {\n      return value.bind(target);\n    }\n\n    return value;\n  }\n\n  static set<T extends object>(\n    target: T,\n    prop: string | symbol,\n    value: any,\n    receiver: any,\n  ): boolean {\n    return Reflect.set(target, prop, value, receiver);\n  }\n\n  static has<T extends object>(target: T, prop: string | symbol): boolean {\n    return Reflect.has(target, prop);\n  }\n\n  static deleteProperty<T extends object>(\n    target: T,\n    prop: string | symbol,\n  ): boolean {\n    return Reflect.deleteProperty(target, prop);\n  }\n}\n","// copied from Next.js, and reduced\n// https://github.com/vercel/next.js/tree/canary/packages/next/src/server/web/spec-extension\nimport type { IncomingHttpHeaders } from 'http';\n\nimport { ReflectAdapter } from './reflect';\n\n/**\n * @internal\n */\nclass ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers',\n    );\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError();\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void;\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void;\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void;\n};\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders;\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super();\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver);\n        }\n\n        const lowercased = prop.toLowerCase();\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased,\n        );\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return;\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver);\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver);\n        }\n\n        const lowercased = prop.toLowerCase();\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased,\n        );\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver);\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop);\n\n        const lowercased = prop.toLowerCase();\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased,\n        );\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false;\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original);\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop);\n\n        const lowercased = prop.toLowerCase();\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased,\n        );\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true;\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original);\n      },\n    });\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable;\n          default:\n            return ReflectAdapter.get(target, prop, receiver);\n        }\n      },\n    });\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ');\n\n    return value;\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers;\n\n    return new HeadersAdapter(headers);\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name];\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value];\n    } else if (Array.isArray(existing)) {\n      existing.push(value);\n    } else {\n      this.headers[name] = value;\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name];\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name];\n    if (typeof value !== 'undefined') return this.merge(value);\n\n    return null;\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined';\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value;\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any,\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this);\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase();\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string;\n\n      yield [name, value] as [string, string];\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase();\n      yield name;\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string;\n\n      yield value;\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries();\n  }\n}\n","// copied from Next.js, and reduced\n// https://github.com/vercel/next.js/tree/canary/packages/next/src/server/web/spec-extension\nimport { RequestCookies } from '../cookies';\nimport { ResponseCookies } from '../cookies';\nimport { ReflectAdapter } from './reflect';\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options',\n    );\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError();\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies };\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>;\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable;\n          default:\n            return ReflectAdapter.get(target, prop, receiver);\n        }\n      },\n    });\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies');\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies,\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ];\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return [];\n  }\n\n  return modified;\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie];\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies,\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies);\n  if (modifiedCookieValues.length === 0) {\n    return false;\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers);\n  const returnedCookies = resCookies.getAll();\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie);\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie);\n  }\n\n  return true;\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>;\n","import { ProviderData } from '../types';\n\nexport async function mergeProviderData(\n  itemsPromises: (Promise<ProviderData> | ProviderData)[],\n): Promise<ProviderData> {\n  const items = await Promise.all(\n    itemsPromises.map((p) => Promise.resolve(p).catch(() => null)),\n  );\n\n  return items\n    .filter((item): item is ProviderData => Boolean(item))\n    .reduce<ProviderData>(\n      (acc, item) => {\n        Object.entries(item.definitions).forEach(([key, definition]) => {\n          if (!acc.definitions[key]) acc.definitions[key] = {};\n          Object.assign(acc.definitions[key], definition);\n        });\n\n        if (Array.isArray(item.hints)) acc.hints.push(...item.hints);\n\n        return acc;\n      },\n      { definitions: {}, hints: [] },\n    );\n}\n"],"mappings":"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","names":["name","value","verifyAccess","name"]}